<!DOCTYPE html>

<html>
<head>
  <meta charset="utf-8">
  <link href="https://markable.in/static/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://markable.in//static/css/style.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="https://markable.in/static/editor/css/view_file.css">
  <link rel="stylesheet" type="text/css" href="https://markable.in/static/css/code.css">
</head>
<body>
  <div class="container">
    <div id="content">
      <p>(before regression)</p>
<p>svn checkout -r1573075 https://svn.apache.org/repos/asf/jackrabbit/oak/trunk</p>
<h2 id="jackrabbit1573075oaktrunkoak-coresrcmainjavaorgapachejackrabbitoakcoremutabletreejava">jackrabbit1573075/oak/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java</h2>
<pre><code>    @Override
    public boolean remove() {
        beforeWrite();
        if (parent != null &amp;&amp; parent.hasChild(name)) {
            nodeBuilder.remove();
            <FONT COLOR="red" >if (parent.hasOrderableChildren()) {
                parent.nodeBuilder.setProperty(
                        PropertyBuilder.copy(NAME, parent.nodeBuilder.getProperty(TreeConstants.OAK_CHILD_ORDER))
                                .removeValue(name)
                                .getPropertyState()
                );
            }</FONT>
            root.updated();
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Tree addChild(String name) {
        checkArgument(!isHidden(name));
        beforeWrite();
        if (!super.hasChild(name)) {
            nodeBuilder.setChildNode(name);
             <FONT COLOR="red" >if (hasOrderableChildren()) {
                nodeBuilder.setProperty(
                        PropertyBuilder.copy(NAME, nodeBuilder.getProperty(TreeConstants.OAK_CHILD_ORDER))
                                .addValue(name)
                                .getPropertyState());
            }</FONT>
            root.updated();
        }
        return createChild(name);
    }

    @Override
    public void setOrderableChildren(boolean enable) {
        beforeWrite();
        if (enable) {
             <FONT COLOR="red" >ensureChildOrderProperty(); </FONT>
        } else {
            <FONT COLOR="red" >nodeBuilder.removeProperty(TreeConstants.OAK_CHILD_ORDER);</FONT>
        }
    }

    @Override
    public boolean orderBefore(final String name) {
        beforeWrite();
        if (parent == null) {
            // root does not have siblings
            return false;
        }
        if (name != null) {
            if (name.equals(this.name) || !parent.hasChild(name)) {
                // same node or no such sibling (not existing or not accessible)
                return false;
            }
        }
        // perform the reorder
        <FONT COLOR="red" >parent.ensureChildOrderProperty();
        // all siblings but not this one
        Iterable&lt;String&gt; siblings = filter(
                parent.getChildNames(),
                new Predicate&lt;String&gt;() {
                    @Override
                    public boolean apply(String name) {
                        return !MutableTree.this.name.equals(name);
                    }
                });
        // create head and tail
        Iterable&lt;String&gt; head;
        Iterable&lt;String&gt; tail;
        if (name == null) {
            head = siblings;
            tail = Collections.emptyList();
        } else {
            int idx = indexOf(siblings, new Predicate&lt;String&gt;() {
                @Override
                public boolean apply(String sibling) {
                    return name.equals(sibling);
                }
            });
            head = Iterables.limit(siblings, idx);
            tail = Iterables.skip(siblings, idx);
        }
        // concatenate head, this name and tail
        parent.nodeBuilder.setProperty(
                MultiGenericPropertyState.nameProperty(
                        TreeConstants.OAK_CHILD_ORDER, Iterables.concat(head, Collections.singleton(getName()), tail))
        );</FONT>
        root.updated();
        return true;
    }


    /**
     <FONT COLOR="red" >* Update the child order with children that have been removed or added.
     * Added children are appended to the end of the {@link org.apache.jackrabbit.oak.plugins.tree.TreeConstants#OAK_CHILD_ORDER}
     * property.



     */
    void updateChildOrder() {
        if (!hasOrderableChildren()) {
            return;
        }
        Set&lt;String&gt; names = Sets.newLinkedHashSet();
        for (String name : getChildNames()) {
            if (nodeBuilder.hasChildNode(name)) {
                names.add(name);
            }
        }
        for (String name : nodeBuilder.getChildNodeNames()) {
            names.add(name);
        }
        PropertyBuilder&lt;String&gt; builder = PropertyBuilder.array(NAME, TreeConstants.OAK_CHILD_ORDER);
        builder.setValues(names);
        nodeBuilder.setProperty(builder.getPropertyState());</FONT>
    }
    /**
     <FONT COLOR ="red">* Ensures that the {@link org.apache.jackrabbit.oak.plugins.tree.TreeConstants#OAK_CHILD_ORDER} exists. This method will create
     * the property if it doesn't exist and initialize the value with the names
     * of the children as returned by {@link NodeBuilder#getChildNodeNames()}.
     */
    private void ensureChildOrderProperty() {
        if (!nodeBuilder.hasProperty(TreeConstants.OAK_CHILD_ORDER)) {
            nodeBuilder.setProperty(
                    MultiGenericPropertyState.nameProperty(TreeConstants.OAK_CHILD_ORDER, nodeBuilder.getChildNodeNames()));
        }
    }</FONT>

}
</code></pre>
<p>//failed test:</p>
<pre><code>org.apache.jackrabbit.mk.store.DefaultRevisionStoreTest,
org.apache.jackrabbit.mk.MicroKernelImplTest,
org.apache.jackrabbit.oak.plugins.document.SimpleTest,
org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlManagerImplTest
</code></pre>
<hr />
<p>(regressed version)
svn checkout -r1579349 https://svn.apache.org/repos/asf/jackrabbit/oak/trunk</p>
<h2 id="jackrabbit1579349oaktrunkoak-coresrcmainjavaorgapachejackrabbitoakcoremutabletreejava">jackrabbit1579349/oak/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java</h2>
<pre><code>  @Override
    public boolean remove() {
        beforeWrite();
  if (parent != null &amp;&amp; parent.hasChild(name)) {
            nodeBuilder.remove();
           <FONT COLOR="red" > updateChildOrder(false);</FONT>
            root.updated();
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Tree addChild(String name) {
        checkArgument(!isHidden(name));
        beforeWrite();
        if (!super.hasChild(name)) {
            nodeBuilder.setChildNode(name);
            <FONT COLOR="red" >updateChildOrder(false);</FONT>
            root.updated();
        }
        return createChild(name);
    }

    @Override
    public void setOrderableChildren(boolean enable) {
        beforeWrite();
        if (enable) {
            <FONT COLOR="red" >updateChildOrder(true);</FONT>
        } else {
             <FONT COLOR="red" >nodeBuilder.removeProperty(OAK_CHILD_ORDER);</FONT>
        }
    }

    @Override
    public boolean orderBefore(final String name) {
        beforeWrite();
        if (parent == null) {
            // root does not have siblings
            return false;
        }
        if (name != null) {
            if (name.equals(this.name) || !parent.hasChild(name)) {
                // same node or no such sibling (not existing or not accessible)
                return false;
            }
        }
        // perform the reorder
        <FONT COLOR= "red">List&lt;String&gt; names = newArrayList();

        for (String n : parent.getChildNames()) {
            if (n.equals(name)) {
                names.add(this.name);

            }
            if (!n.equals(this.name)) {
                names.add(n);
            }

        }
        if (name == null) {
            names.add(this.name);

        }
        parent.nodeBuilder.setProperty(OAK_CHILD_ORDER, names, NAMES);</FONT>
        root.updated();
        return true;
    }

    /**
     <FONT COLOR= "red">* Updates the child order to match any added or removed child nodes that
     * are not yet reflected in the {@link TreeConstants#OAK_CHILD_ORDER}
     * property. If the {@code force} flag is set, the child order is set
     * in any case, otherwise only if the node already is orderable.
     *
     * @param force whether to add child order information if it doesn't exist
     */
    void updateChildOrder(boolean force) {
        if (force || hasOrderableChildren()) {
            nodeBuilder.setProperty(PropertyStates.createProperty(


                    OAK_CHILD_ORDER, getChildNames(), Type.NAMES));

        }</FONT>

    }
</code></pre>
<p>//failed test:</p>
<pre><code>org.apache.jackrabbit.mk.store.DefaultRevisionStoreTest,
org.apache.jackrabbit.mk.MicroKernelImplTest,
org.apache.jackrabbit.oak.plugins.document.SimpleTest,
org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlManagerImplTest,
org.apache.jackrabbit.oak.plugins.document.blob.RDBBlobStoreTest
</code></pre>
<p>// relation entre la class RDBBlobStoreTest.java et MutableTree.java</p>
<pre><code>RDBBlobStoreTest extends AbstractBlobStoreTest

protected GarbageCollectableBlobStore store;


    @Test
    public void delete() throws Exception {
        Set&lt;String&gt; ids = createArtifacts();

        store.deleteChunks(Lists.newArrayList(ids), 0);

        Iterator&lt;String&gt; iter = store.getAllChunkIds(0);
        Set&lt;String&gt; ret = Sets.newHashSet();
        while (iter.hasNext()) {
            ret.add(iter.next());
        }
        assertTrue(ret.toString(), ret.isEmpty());
    }


    GarbageCollectableBlobStore extends BlobStore
</code></pre>
<hr />
<p>(corrected version)
svn checkout -r1579637 https://svn.apache.org/repos/asf/jackrabbit/oak/trunk</p>
<h2 id="jackrabbit1579637oaktrunkoak-coresrcmainjavaorgapachejackrabbitoakcoremutabletreejava">jackrabbit1579637/oak/trunk/oak-core/src/main/java/org/apache/jackrabbit/oak/core/MutableTree.java</h2>
<p>import static com.google.common.collect.Sets.newLinkedHashSet;
import java.util.Set;</p>
<pre><code>    @Override
    public boolean remove() {
        beforeWrite();
        if (parent != null &amp;&amp; parent.hasChild(name)) {
            nodeBuilder.remove();
            <FONT COLOR="green" >PropertyState order = parent.nodeBuilder.getProperty(OAK_CHILD_ORDER);
            if (order != null) {
                Set&lt;String&gt; names = newLinkedHashSet(order.getValue(NAMES));
                names.remove(name);
                parent.nodeBuilder.setProperty(OAK_CHILD_ORDER, names, NAMES);
            }</FONT>
            root.updated();
            return true;
        } else {
            return false;
        }
    }

    @Override
    public Tree addChild(String name) {
        checkArgument(!isHidden(name));
        beforeWrite();
        if (!super.hasChild(name)) {
            nodeBuilder.setChildNode(name);
            <FONT COLOR="green" >PropertyState order = nodeBuilder.getProperty(OAK_CHILD_ORDER);
            if (order != null) {
                Set&lt;String&gt; names = newLinkedHashSet(order.getValue(NAMES));
                names.add(name);
                nodeBuilder.setProperty(OAK_CHILD_ORDER, names, NAMES);
            }</FONT>
            root.updated();
        }
        return createChild(name);
    }
</code></pre>
<p>//failed test:</p>
<pre><code>org.apache.jackrabbit.mk.store.DefaultRevisionStoreTest,
org.apache.jackrabbit.mk.MicroKernelImplTest,
org.apache.jackrabbit.oak.plugins.document.SimpleTest,
org.apache.jackrabbit.oak.security.authorization.accesscontrol.AccessControlManagerImplTest
</code></pre>
    </div>
  </div>
</body>
</html>